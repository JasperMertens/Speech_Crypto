#include <stdio.h>
#include <stdlib.h>
#include "format.h"
#include "aes.h"
#include "encryption.h"
/*#include "sha2.h"*/
#include "sha256.h"
#include "montgomery2.h"
#include "padding.h"
#include "handshake.h"
#include "datagram.h"
#include "global.h"
#include <string.h>
#include "master_fsm.h"



void printArray(uint32_t *array, int size)
{
	int i;
	printf("Result: 0x%08x", array[size-1]);
	for (i=size-2; i>=0; i--) {
		printf("%08x", array[i]);
	}
	printf("\n\r\n\r\n\r");
}


void printCharArray(unsigned char *array, int size)
{
    int i;
	printf("Result: 0x%02x", array[0]);
	for (i=1; i<size; i++) {
		printf("%02x", array[i]);
	}
	printf("\n\r\n\r\n\r");
}

int test_format() {
    uint32_t test_input[8] = {0x11111111, 0x22222222, 0x33333333, 0x44444444, 0x11111111, 0x22222222, 0x33333333, 0x44444444};
    uint8_t converted[32];
    uint32_t deconverted[8];
    printf("Testing format: \r\n");

    printf("Printing input: \r\n");
    printArray(test_input, 8);

    arr32_to_arr8(converted, test_input, 8);
    printf("Printing converted result: \r\n");
    printCharArray(converted, 32);

    arr8_to_arr32(deconverted, converted, 32) ;
    printf("Printing deconverted result: \r\n");
    printArray(deconverted, 8);

    if(memcmp(test_input, deconverted, 8) != 0) {
        fprintf(stderr, "Format failed\n");
        abort();
    }
    return 0;
}

int test_aes()
{
aes_key key;
unsigned char output[16];

	printf("Testing AES: \r\n");

  aes_set_encrypt_key(&key, (unsigned char *)"\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 128);

  aes_encrypt(&key, (unsigned char *)"\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a", output);
  printCharArray(output,16);

  if (memcmp(output, "\x3a\xd7\x7b\xb4\x0d\x7a\x36\x60\xa8\x9e\xca\xf3\x24\x66\xef\x97", 16) != 0) {
    fprintf(stderr, "Encryption failed\n");
    abort();
  }

  aes_set_decrypt_key(&key, (unsigned char *)"\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 128);

  aes_decrypt(&key, (unsigned char *) "\x3a\xd7\x7b\xb4\x0d\x7a\x36\x60\xa8\x9e\xca\xf3\x24\x66\xef\x97", output);

  if (memcmp(output, "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a", 16) != 0) {
    fprintf(stderr, "Decryption failed\n");
    abort();
  }

  return 0;
}

int test_ctr_mode() {
    uint32_t message[] = {0xf484e847, 0x4ae251f1, 0xedfa617d, 0x58ab6bf4};
    int size = 4;
    int Nb_blocks = 1;
    uint32_t iv[3] = {0x00000000,0x00000000,0x00000000};
    uint32_t counter = 0;
    unsigned char sym_key[16] = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";
    uint32_t encrypted_txt[4];
    uint32_t decrypted_txt[4];
    printf("Testing CTR-mode: \r\n");

    printf("Printing plaintext message\r\n");
    printArray(message, size);

    ctr_mode(encrypted_txt, message, Nb_blocks, iv, counter, sym_key);
    printf("Printing encrypted text\r\n");
    printArray(encrypted_txt, size);

    counter = 5;
    ctr_mode(encrypted_txt, message, Nb_blocks, iv, counter, sym_key);
    printf("Printing encrypted text with different counter\r\n");
    printArray(encrypted_txt, size);

    ctr_mode(decrypted_txt, encrypted_txt, Nb_blocks, iv, counter, sym_key);
    printf("Printing decrypted text\r\n");
    printArray(decrypted_txt, size);

    if (memcmp(message, decrypted_txt, size) != 0) {
        fprintf(stderr, "Encryption failed\n");
        abort();
    }
    return 0;
}

int test_sha2() {
    #define SHA2_TESTVECTOR 1
    size_t len;

    BYTE buf[SHA256_BLOCK_SIZE];
	SHA256_CTX ctx;

    #if SHA2_TESTVECTOR == 1
    unsigned char test_input[3] = {'a','b','c'};
    unsigned char expected_output[32] = {0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,
                                        0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad};
    /*len = sizeof(test_input);*/
    len = 3;

    #elif SHA2_TESTVECTOR == 2
    unsigned char test_input[] = {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"};
    unsigned char expected_output[32] = {0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
                                        0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,0xf6,0xec,0xed,0xd4,0x19,0xdb,0x06,0xc1};
    len = strlen(test_input);

    #else /* SHA2_TESTVECTOR */
    unsigned char test_input[] = {"aaaaaaaaaa"};
    unsigned char expected_output[32] = {0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,
                                        0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0};

    #endif /* SHA2_TESTVECTOR */
    /*unsigned char digest_string[65];
    unsigned char allocate[33];
    unsigned char *hash_output = allocate;*/

    printf("Testing SHA2: \r\n");

    printf("Printing expected output: \r\n");
    printCharArray(expected_output,32);

    /*hash_output = SHA256_Data(test_input, 3, digest_string);
    hash_output++;*/ /* eentje opschuiven */

    sha256_init(&ctx);
	sha256_update(&ctx, test_input, len);
	sha256_final(&ctx, buf);

    printf("Printing hash output: \r\n");
    printCharArray(buf, 32);

    if (memcmp(buf, expected_output, 32) != 0) {
        fprintf(stderr, "Hash failed\r\n");
        abort();
    }

   /*
    uint32_t test_input[67] = {0x00000001, 0x00000000, 0x00000000, 0x7b3c33fe, 0x16a2b6a0, 0x6f5ce067, 0xbdceaa18, 0x3da1be41, 0xe6a3109a, 0x2c14b574, 0x311e53fd, 0x0eae6126, 0x5d520309, 0xdb46cc2b, 0xc09d6a4e, 0x11f8d6da, 0x9fee8e74, 0xf9739b6a, 0x57776caa, 0xb1e4cfa0, 0xeccdc3d3, 0xfd769e3c, 0x440e8d09, 0x82ad868e, 0xfdff0955, 0x7833f6bc, 0xddd5a56c, 0xf6c6cbf9, 0x576dfb98, 0xad34ae66, 0xf861a1d6, 0x1c1e5663, 0xa3b93294, 0x53371ff4, 0x717a6cb0, 0xd88ed776,
    0x40ae96d5, 0xb07f9895, 0x0c4279ce, 0x165fc9e5, 0xd1df3701, 0x5f75a5f3, 0x8f9d4596, 0x5d06bcea, 0x95b47875, 0x37df9cce, 0x6d8727da, 0x0d2e4310, 0xd3dfb3c6, 0xf5b7a61a, 0x54ece5a7, 0x84a73600, 0xeb10841d, 0x28d8693f, 0xca26f202, 0x56ba9a1f, 0x8acce269, 0xff5727fa, 0xbabe0e76, 0x7521281c, 0xd3273d2b, 0x3e52f109, 0x5e021dcc, 0xeb3ed84f, 0xb9015b2d, 0x92197501, 0x2a853b3d};
    uint32_t result[8];

    unsigned char hash_input[268];
    unsigned char digest_string[65] = {0};
    unsigned char allocate[33];
    unsigned char *hash_output = allocate;

    printf("Printing test_input: \r\n");
    printArray(test_input, 67);

    arr32_to_arr8(hash_input, test_input, 67);
    hash_output = SHA256_Data(hash_input, 268, digest_string);
    printCharArray(hash_output, 32);

    sha256(result, test_input, 67);
    printArray(result, 8);
    */

   return 0;
}


int test_montgomery() {

    /*uint32_t a[32] = {0xf484e847, 0x4ae251f1, 0xedfa617d, 0x58ab6bf4, 0x46bf4848, 0xf67c1061, 0x8811c17a, 0x578fde16, 0x493ee595, 0x1eafc4c3, 0xc4f11a2e, 0x8cb6fba7, 0x724c03a4, 0x2e6c1dbd, 0x57ebc43d, 0x3e6ee260, 0x4089c050, 0xf0384e03, 0x7357f72c, 0x87acb658, 0x7ea2490e, 0x61069112, 0x42e3f8b9, 0x9e778cef, 0x5cdf77c7, 0x10bce41c, 0x1121beec, 0x3db59a36, 0xc34620c5, 0xc6b030ae, 0xe8fc5934, 0x63a0a0cb};
    uint32_t b[32] = {0xfeb1b9f4, 0xe91d3bec, 0xfb09354d, 0x07f21d6d, 0x9ece9e1b, 0x18def18b, 0x4119e1e9, 0x55c85f24, 0x60ef0e23, 0x10e8ab54, 0x1e95cdcc, 0x4373912f, 0x6f42204d, 0x7126650d, 0xb61c1c8d, 0x98af9011, 0xa42c03b4, 0xd29e0870, 0x7923cb60, 0xdf87cfe5, 0xde4fffa0, 0x3ce537ca, 0x201040c6, 0x6e54b058, 0x814c53dc, 0xf16243f0, 0x57decf64, 0x8d0d4f37, 0x9b6d93e5, 0x45396d71, 0x615213c4, 0x65f89f9f};
    uint32_t N[32] = {0x4aeeb107, 0x5d78aa98, 0x6c55dd05, 0x6f5326c9, 0xf93f738c, 0xc10fa093, 0x20478120, 0x099d6d70, 0x833d9b82, 0x1248f3ed, 0xa43ed737, 0xc1c1da45, 0x9f23e5c7, 0xb17c3598, 0xe8938df6, 0x7ae59036, 0x9f84d87b, 0xc8710dc6, 0x249ee0f8, 0x46eeae2f, 0x66a3bb9b, 0xfeef4c6b, 0xc7b55eae, 0x7951dd0c, 0x0b4391e8, 0x141ad586, 0x1a568588, 0x908293dd, 0x472c0bea, 0x8d00abfe, 0xed17377f, 0x83a01efe};
    uint32_t n_prime[32] = {0xe7d41349, 0x0c828dcd, 0x2dc06d90, 0x318f87bf, 0x1992ba09, 0x4b1bef10, 0x011ba664, 0xe3a7d9cf, 0x44449fbd, 0x89714d34, 0x6cd49cc4, 0x49c5b99d, 0xf90435b1, 0x38f037b7, 0xba9720db, 0x9641b106, 0xbca01d2a, 0xfdb82893, 0xbd7ce9c7, 0x372823e1, 0x4901cdde, 0xaa28d457, 0xe9f78c94, 0xb6e1e5b3, 0x5a79f7a6, 0xf5212a83, 0x2b1aab45, 0xa3924b69, 0x3c63a8af, 0x12fa121d, 0x7500bea0, 0xe58878e7};

    uint32_t expected_output[32] = {0xeb7e3ef3, 0x40b90c4f, 0xd9c234b1, 0x2461cd34, 0x183481c7, 0x0bc4e5bd, 0x4803996e, 0x755d1777, 0x698f88c7, 0x2e78b03b, 0xa55cfb32, 0x74d1c12a, 0xc6bc8934, 0x581d4714, 0x7d504a58, 0xb29753f1, 0x99ae0c37, 0x65c4cc3a, 0x4153aacb, 0xe0a5c4bf, 0xce0a9c7c, 0x4babfb22, 0x75aa490d, 0x43b6ec25, 0xdcb17a10, 0x47deec3c, 0xd0e2735f, 0x16726b8e, 0x0f486246, 0x0f74d471, 0xe62a3577, 0x065a0397};
    */
    /*
    uint32_t a[32] = {0x95401e33, 0xf2e5f538, 0xcd340e16, 0x5fe4fd66, 0xac500fe0, 0x748f18fe, 0xdad8575e, 0xce2058bb, 0x00c35266, 0xd51c8064, 0xfefeb38e, 0xc7ed29eb, 0xdb438313, 0x6550e48e, 0x02489732, 0xedaf8b6b, 0x5dd5313d, 0xa328f036, 0x419a784e, 0x23d635bb, 0x25143077, 0x48996382, 0xaa396499, 0xf24a2910, 0xb60ee4dc, 0xdfede44c, 0x69f174f6, 0x917d544c, 0x3c80aecf, 0xc90096c4, 0xc52a6c88, 0x07d92c14};
    uint32_t b[32] = {0xd7040630, 0xc765f25a, 0x4a7230d6, 0x395c2b8b, 0xaec10e86, 0xb62173f6, 0x72096da0, 0xc0ed3b81, 0x240e4293, 0xac5a2199, 0x5d05fed8, 0xadcae3e6, 0x22704082, 0x3b74cdb2, 0x51f0df68, 0xde5b7e6f, 0x66dc5f67, 0x0a836d5e, 0x32edcdb9, 0x4332989f, 0xedef232c, 0x25167785, 0x34d884aa, 0xfdf337de, 0xd7532d14, 0xa4b160f1, 0xf833b81c, 0xaa9589fb, 0xef7f7ade, 0x6ccff27d, 0x747a7bb0, 0x1f8042e7};
    uint32_t N[32] = {0xc6df4c85, 0x08e49be7, 0xe6f266e4, 0x450ca4b0, 0x028def7e, 0x3bdf79cf, 0xd3c65a9b, 0xd278192c, 0x08fd96bf, 0x5d635e17, 0xac3f28b1, 0x8449d487, 0xdd42688c, 0x61419fe8, 0x6b674328, 0x8f6bd9e2, 0x8e47420e, 0x94711c9e, 0x22f7165a, 0x2485755e, 0x61561df6, 0xf664e91d, 0xd97d05ce, 0xf221e0fd, 0xfd772f68, 0xf1856267, 0xe9041ac4, 0x2fd12fc8, 0x34b9220f, 0x695e5d77, 0x6b079c2c, 0x86ad4952};
    uint32_t n_prime[32] = {0x14d333b3, 0xc3b3be8f, 0x02ca4af0, 0xc43aba10, 0xde20e9cb, 0xc88222f9, 0x80860cc0, 0x315e4cf8, 0x0a2cc4f4, 0x16376d50, 0xcc1720b7, 0x8af0c35b, 0xc3ece9e9, 0x8f01dccc, 0x42d96568, 0xc02be3a4, 0x71e50c92, 0xb050887c, 0x4df93c3d, 0x75a13c65, 0xcd504fe2, 0x99ac5e4c, 0xc9f348e7, 0xb95f9a0e, 0xe170a1f0, 0x4769f246, 0x913001b4, 0xfc05df41, 0x63dc5efb, 0x9a863fbe, 0xc1f39f28, 0xf1295524};

    uint32_t expected_output[32] = {0xe4a627f2, 0x44ced61c, 0xb41445b2, 0x1deec41a, 0x00ec59c6, 0x366243e9, 0x8b3a5383, 0x293a279e, 0xb57482b8, 0x28a49995, 0xd5012ddd, 0xa1427bbf, 0xa4586c9c, 0x7df6bde0, 0x923e818c, 0xe215dbb8, 0x3a62ed6c, 0xe0f76529, 0x2d2936f3, 0x54e7fa14, 0x18022409, 0x6d5160c4, 0x998fe1c4, 0x86dab2c2, 0x46eda221, 0x6f93d1e2, 0xe9e57d26, 0xfb42688f, 0x679e9aa1, 0x6b70806a, 0x85d91b9f, 0x6a7decd7};
    */

    /*
    uint32_t a[16] = {0x51977946, 0x7957b1be, 0x9f030fbd, 0x04561a82, 0x1fad9525, 0xab8e0526, 0x05c0a4a8, 0x4dcc3907, 0xc8ae12c7, 0x8b7d54ca, 0x22e43d05, 0x806b8cac, 0x13cbfd6b, 0x36d3028f, 0x52132ef0, 0xc51931a9};
    uint32_t b[16] = {0x5fc3d1ef, 0x96dec894, 0x2d5929f7, 0xc0810a9f, 0x8b55af12, 0x3548fef6, 0x3d61e914, 0xc5784013, 0x20669791, 0x154a73de, 0x98e985d3, 0xe3d56445, 0xcb4fba56, 0x5f0012cc, 0xca83b655, 0xb220f8c0};
    uint32_t N[16] = {0x0ebd5f75, 0x948cb7ab, 0x58727656, 0x0f02d0b4, 0x6ed897f2, 0x052304af, 0xcea1ed9f, 0x2e3b3a4c, 0xaa19906f, 0x0a3be041, 0x6ae0754b, 0x28470c40, 0xc871a4de, 0x10943525, 0x105d393e, 0xc6bb131b};
    uint32_t n_prime[16] = {0x7648c723, 0xdc590cb1, 0xbb4c5143, 0x58be381a, 0x7f1c698f, 0x46297b6c, 0xb991e392, 0x3d7d04c2, 0xa0eb979b, 0x3f231be6, 0x9c6760bf, 0x4ed1e95f, 0x464cc4b6, 0xde39afa8, 0xa1bfa709, 0xed55fac2};
    uint32_t expected_output[16] = {0x9e31ea81, 0xe265cbb7, 0x5e453a5a, 0xffe854d5, 0x58b4d35b, 0x5370eae7, 0xfd0d421a, 0x66dd18b8, 0x7b232ec6, 0xb6df247f, 0x3f359f29, 0x4c244688, 0xc901b64c, 0xda554d8d, 0x7e49f069, 0x9712a929};
    */

    /* seed 2018 2nd iteration of mod_exp uses performs this multiplication */
    /*
    uint32_t a[32] = {0x83bfde37, 0x4bb9caee, 0xa4b7bc55, 0x96e8674e, 0xaf6bbfe8, 0x0a527da7, 0xf7bc7ea0, 0xb699b8a8, 0x3920848d, 0xaeaf012f, 0x66ebd8c2, 0x5abead95, 0xae5a687b, 0x665240f4, 0x09cda19d, 0x44c26595, 0x9ab850d6, 0x18558d44, 0xf1bb0229, 0x76b9a3c1, 0x57e32029, 0x754ab74d, 0x67a4d489, 0xe225cb67, 0xaf4e9389, 0xe6487bd9, 0x6192265a, 0x2b91e006, 0xb603722b, 0x6b7d9fc5, 0xb23c36b6, 0xc9d91b54};
    uint32_t b[32] = {0x83bfde37, 0x4bb9caee, 0xa4b7bc55, 0x96e8674e, 0xaf6bbfe8, 0x0a527da7, 0xf7bc7ea0, 0xb699b8a8, 0x3920848d, 0xaeaf012f, 0x66ebd8c2, 0x5abead95, 0xae5a687b, 0x665240f4, 0x09cda19d, 0x44c26595, 0x9ab850d6, 0x18558d44, 0xf1bb0229, 0x76b9a3c1, 0x57e32029, 0x754ab74d, 0x67a4d489, 0xe225cb67, 0xaf4e9389, 0xe6487bd9, 0x6192265a, 0x2b91e006, 0xb603722b, 0x6b7d9fc5, 0xb23c36b6, 0xc9d91b54};
    uint32_t N[32] = {0x3b6021e5, 0x134c079f, 0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0xd6369bca};
    uint32_t n_prime[1] = {0xb7bfcc13};
    uint32_t expected_output[32] = {0x32d84340, 0x3a3e6880, 0x3f632a75, 0x2ed7d896, 0x4e8177d9, 0x74458b42, 0xad6a9b6c, 0x25fc5bf2, 0x03217fcb, 0xd6d9ba7c, 0x29d1d141, 0xb156774f, 0x50731532, 0x46db2146, 0xb410bf5d, 0x3f048b1b, 0xeaa83826, 0x30eaf592, 0xd90cd3ff, 0xe8c4c0c3, 0xfe763e67, 0x742f8f31, 0xe2f7181d, 0x546dd84a, 0xad7bd802, 0x8848727c, 0x5204c8d5, 0x15cc471f, 0x06c461a6, 0x758f0bb4, 0x0af98f85, 0x49f887aa};
    */

    /* Testvector 1 from Toledo*/
    /*
    uint32_t a[5] = {0xcdb7a16a, 0x1ee34005, 0xe62d7186, 0xd54960de, 0x45264014};
    uint32_t b[5] = {0x7fbab408, 0x6182b5d3, 0x2a764f79, 0x12bc9c42, 0x76b78efd};
    uint32_t N[5] = {0x37af2027, 0xb2b16f3f, 0x2ce6387f, 0xc543b079, 0x998e281a};
    uint32_t n_prime[5] = {0x4e07b069, 0xc8b14bac, 0x079fe34f, 0xda3729ea, 0x7f627ffa};
    //uint32_t n_prime[1] = {0x4e07b069};
    uint32_t expected_output[5] = {0x1f536a51, 0xaf5e3d34, 0xc66661f6, 0x641191d7, 0x9426d619};
    */


    /* Testvector 2 from Toledo, the length of R is not a multiple of the wordlength 32 */
   /* uint32_t a[4] = {0xa3f32302, 0x2b1fdb47, 0xcfaaa648, 0x0000140f};
    uint32_t b[4] = {0x988ce22f, 0x9dc6deb2, 0x372c2f40, 0x00000c09};
    uint32_t N[4] = {0xe4d278fb, 0x9ded7165, 0x10f19b72, 0x00001d56};
    uint32_t n_prime[1] = {0x47c32dcd};
    uint32_t expected_output[4] = {0x3c540e0b, 0xd07fa434, 0xa7a261b2, 0x000014d5};
    //uint32_t expected_output[32] = {0x401f5e11, 0x3e25dddf, 0x79863a4d, 0x00000fb2, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000};
    */

    /* Test RSA mont */
    uint32_t a[39] = {0xa3f32302, 0x2b1fdb47, 0xcfaaa648, 0x0000140f,0};
    uint32_t b[39] = {0x988ce22f, 0x9dc6deb2, 0x372c2f40, 0x00000c09,0};
    uint32_t N[39] = {0x0555df83, 0x5f4cf186, 0x41a74eab, 0x555d4665, 0xa85b8f09, 0xd41c5091, 0x2251f04b, 0xb4c1b0b0, 0xf58f1563, 0x87e3be3b, 0x475120f2, 0xcd2faac9, 0xb6a53cda, 0x91da4ab2, 0xf6b47377, 0x99b511ad, 0xc1aa3e02, 0x66156ad9, 0x00b62491, 0xd25d048c, 0xaa5c77e1, 0x0c005883, 0x189f583d, 0xf9b19c87, 0x8674c144, 0xbc619e38, 0xa6e53c26, 0xee532d31, 0x012b534e, 0xda52fc8c, 0xefaf19a7, 0x099e31cb, 0x5e151b21, 0x421307c2, 0x03afe93c, 0x2cb52503, 0x59a36580, 0x03e92f99, 0xb2209191};
    uint32_t n_prime[39] = {0xd4e858d5, 0xe0e86cbf, 0x3168a7c2, 0x46096eb1, 0x4fd03415, 0xf133a9c5, 0x9af4d222, 0xf999034e, 0x96177585, 0x4b9e730d, 0xe01d3389, 0xbe60865c, 0x7cd2877e, 0x524405d7, 0x6485feeb, 0x11a0e3b0, 0x2a0fbf19, 0x8c2a2b78, 0x690fc96e, 0x79ab9bfd, 0x2a2057ce, 0xffa119d4, 0x60b48475, 0xd7b41f4d, 0xb0b4693a, 0x7e03503e, 0x49684888, 0x8a07f270, 0xc5fbea68, 0x8676c7ec, 0x6fc64ee3, 0x8776f2da, 0x7729d7ca, 0x616b86df, 0x7a010fd4, 0xaa154ce9, 0x198d25ae, 0xc028ccdd, 0x3b71bdbd};
    uint32_t expected_output[39] = {0xba614717, 0x94553644, 0xa65a978d, 0x2c720e1d, 0x0c90ec45, 0xeddec42b, 0x81366cb8, 0xb20449ca, 0x44ba03ff, 0x7a61cf4a, 0x7c306896, 0xc7600cfe, 0xdca7dac4, 0x95805e52, 0xd45fdb99, 0xb367e3bb, 0x661d536f, 0xbfe7933c, 0x29bf49cd, 0xda090dac, 0x8a3fb62f, 0x3d658985, 0x886dbab3, 0xdbe66b7d, 0xdd16c528, 0xf456fafa, 0xb8e88910, 0xbe71a5d8, 0xb12d780b, 0xd57e9a83, 0xf47eefb4, 0x9275e8db, 0x1f3357d4, 0xe7d5c79d, 0x90bf5b99, 0xa28fc928, 0xb4bcf2c9, 0xb35f7351, 0x9170db4b};



    uint32_t size = 39;
    /* uint32_t mont_mul[39]; */
    uint32_t mont_mul2[39];
    printf("Testing montgomery\r\n");

    printf("Printing expected output: \r\n");
    printArray(expected_output, size);


    /* mont(a, b, N, n_prime, mont_mul, size); */
    mont_mult(a, b, N, n_prime, mont_mul2, size);


    printf("Printing montgomery result: \r\n");
    printArray(mont_mul2, size);

    /*
    if (memcmp(mont_mul, mont_mul2, size) == 0) {
        printf("Equal\r\n");
    }
    */
    if (memcmp(mont_mul2, expected_output, size) != 0) {
        fprintf(stderr, "Montgomery failed\r\n");
        abort();
    }
    return 0;
}

int test_exponentiation() {
    #define EXP_TESTVECTOR 8

    #if EXP_TESTVECTOR == 1
    // message
    uint32_t X[32] = {0xd1f72277, 0x5bcebff7, 0x0f28d9ed, 0xe43362d8, 0xc5c6c315, 0x855753eb, 0xcb9978eb, 0xb04d99ad, 0x01c7c457, 0x2b5ccae1, 0x2b623a24, 0x4d9ce47f, 0x70f0f243, 0xc770f081, 0x67f34a9b, 0x18229f68, 0xdf327808, 0x00a34197, 0x0525ffdb, 0xf4b5797c, 0xdc1eed8f, 0xa115f7e8, 0x35e7960a, 0x7ec4d255, 0x7ec475ec, 0x6184c174, 0x8f3ef993, 0x0df6bbaa, 0x22928bf8, 0x6f58f75d, 0x00121ef8, 0x8736b775};
    // modulus
    uint32_t M[32]       = {0xbbfc20bd, 0x36ad0309, 0x4fae157f, 0xc4ea08c0, 0x0d37681c, 0x07e72b82, 0xf345dca3, 0x4a723f88, 0xdcf5ac59, 0x06b8a6b2, 0x368a00f3, 0xdb7d2058, 0x2c9dbb28, 0x124e2690, 0xcdd19842, 0x5ae15e97, 0xe2bda701, 0x9d11ea54, 0xe18c6fc9, 0xe0c3160c, 0xa00703b0, 0x1e21f6b5, 0xaf942238, 0xbe210e79, 0xc2ca886b, 0x6c20ecb1, 0xfcafdd9e, 0xba6224ee, 0xf80d650a, 0xd3119ff0, 0x8149d93a, 0x88c7a0f9};
    uint32_t M_prime[32] = {0x7e1f256b, 0x83dbe076, 0x6640a5e5, 0x7b9efc19, 0xcda50596, 0xd7b39c97, 0x4d8cb877, 0x3dfed80f, 0x7bc6ab2b, 0x66833e2c, 0x544cf630, 0xea63f8c9, 0x24dd3f41, 0x0ceb1ef4, 0x7cda2f92, 0xd5521efe, 0x9cf36016, 0x12fbe409, 0x46775528, 0xd346ccda, 0xb184f914, 0x981b516b, 0x75eb8385, 0x39c7425d, 0x8733bd5c, 0xd2a971df, 0x4a718971, 0x093ce057, 0xc3268d0a, 0x89da0333, 0x587151e7, 0x66edd04d};
    // encryption exponent
    uint32_t E[32] = {0x0000ef6b};
    uint32_t exp_len = 16;
    // R mod N, and R^2 mod N, (R = 2^1024)
    uint32_t R[32]  = {0x4403df43, 0xc952fcf6, 0xb051ea80, 0x3b15f73f, 0xf2c897e3, 0xf818d47d, 0x0cba235c, 0xb58dc077, 0x230a53a6, 0xf947594d, 0xc975ff0c, 0x2482dfa7, 0xd36244d7, 0xedb1d96f, 0x322e67bd, 0xa51ea168, 0x1d4258fe, 0x62ee15ab, 0x1e739036, 0x1f3ce9f3, 0x5ff8fc4f, 0xe1de094a, 0x506bddc7, 0x41def186, 0x3d357794, 0x93df134e, 0x03502261, 0x459ddb11, 0x07f29af5, 0x2cee600f, 0x7eb626c5, 0x77385f06};
    uint32_t R2[32] = {0x22f47dee, 0xf5713476, 0x1cd271a5, 0xcaef844d, 0xe4dfe69e, 0x21310383, 0xa8d683ed, 0x8e3dafe0, 0x3850d425, 0xddd8c78f, 0x027ebe51, 0x69522c83, 0x5b87bdca, 0xed6b9fdd, 0x0a4a4a0b, 0x40e5cf13, 0xe01dc8cc, 0x2d59d31b, 0x48725aa8, 0x4042e36e, 0x9c136c2a, 0xff5afff6, 0xad2bbbce, 0x4805f182, 0x0f651f17, 0x07ba3e74, 0xb04591cf, 0x196464b7, 0x48754ce6, 0xe0983de5, 0x2e4875f2, 0x1356d001};
    uint32_t expected_output[32] = {0x06330823, 0xa8da499b, 0x7adae76a, 0xb8f64269, 0x3d6586b7, 0x59e065e8, 0x19a5670e, 0x883da67d, 0x800ae2b3, 0xb7386f60, 0x24721d27, 0x728e69da, 0xea509ffe, 0x45d521f1, 0x013ed688, 0x4c6ec24d, 0xc84323e9, 0xd271a4e2, 0x4480c8ef, 0x9b9ff918, 0x74d142e6, 0xf6a8061c, 0x18f37e45, 0x2786c35d, 0xa5d51ea9, 0x11ae0a3e, 0xdaf958c9, 0x34cd83ff, 0x8eef0f98, 0x8445fc71, 0xee2a38b5, 0x780946ec};
    uint32_t size = 32;


    #elif EXP_TESTVECTOR == 2
    // message
    uint32_t X[32] = {0xa1f9b6ce, 0xb2280607, 0x24236d19, 0x893c1d9f, 0xbba1e702, 0x889c65d7, 0x463c0845, 0x14dd5add, 0x95f2bdc1, 0x0544a782, 0xac7e26cc, 0x809595e4, 0x5ad6974d, 0x66fcb060, 0x2e36800a, 0x5a3df073, 0x519a860e, 0x7ed1d6a5, 0x2163f769, 0xc4d86c58, 0xd433da74, 0x4b5bcd6a, 0xede84ee3, 0x7eaf5dcb, 0xb2493458, 0x4ab389f4, 0xddfe0216, 0x812a9f4c, 0xc87937ee, 0xcf32f14e, 0xe18435a4, 0x90541eab};
    // modulus
    uint32_t M[32] = {0x4e6fc30b, 0x6d5f9033, 0x3ac93d69, 0x415df9fb, 0xd9652e87, 0x60a7aef2, 0x44b77c4d, 0x847fc030, 0x5cf21cd5, 0x535736da, 0x46ae1b11, 0xfddff04c, 0x84fd9c4b, 0x08cac904, 0x34a95116, 0x49fff604, 0xede53570, 0xbb09ad2c, 0xce07019a, 0x77d3b920, 0x06f3fbd7, 0x8fe6df35, 0xfce4611e, 0xf5072bc5, 0xaf3847f7, 0x2740a725, 0x90ecf0ea, 0x9389ce5e, 0x4e2e474e, 0x66f610cd, 0xac41f79a, 0x960979f7};
    uint32_t M_prime[32] = {0xb2398f5d, 0xe8bb9fa4, 0xa8dee45f, 0xb6e49a9a, 0x652d0405, 0xc9b0505c, 0x5c660752, 0x215439c4, 0xff8acd11, 0x580531cb, 0xed14607e, 0x09737250, 0x3795d3f1, 0x0dcb6f6a, 0x9fbf5fd0, 0xd250464a, 0xa02b3a11, 0xbcbf929b, 0x6e7770a4, 0x36c76dad, 0x1745e15d, 0xaf29ebac, 0xce6ec197, 0xcb747bf7, 0x3df912a0, 0xc5836e88, 0xa3832d3e, 0xad7925cc, 0xc160b4e9, 0xa7e9e3fe, 0x51356d8a, 0x20ef8590};
    // encryption exponent
    uint32_t E[32] = {0x0000e417};
    uint32_t exp_len = 16;
    // R mod N, and R^2 mod N, (R = 2^1024)
    uint32_t R[32]  = {0xb1903cf5, 0x92a06fcc, 0xc536c296, 0xbea20604, 0x269ad178, 0x9f58510d, 0xbb4883b2, 0x7b803fcf, 0xa30de32a, 0xaca8c925, 0xb951e4ee, 0x02200fb3, 0x7b0263b4, 0xf73536fb, 0xcb56aee9, 0xb60009fb, 0x121aca8f, 0x44f652d3, 0x31f8fe65, 0x882c46df, 0xf90c0428, 0x701920ca, 0x031b9ee1, 0x0af8d43a, 0x50c7b808, 0xd8bf58da, 0x6f130f15, 0x6c7631a1, 0xb1d1b8b1, 0x9909ef32, 0x53be0865, 0x69f68608};
    uint32_t R2[32] = {0xafd67099, 0x1057b974, 0x5b5f30e3, 0x8abf56c9, 0x15aead5f, 0x007f37b8, 0xfc5e5375, 0xf354bc3d, 0x93f5cbd3, 0x129b3c53, 0xb185bce7, 0x553b5c6a, 0x69611f46, 0xaa095a06, 0xb1eaf678, 0x3b7bc563, 0xd0c17574, 0x10d9a47d, 0xd2346905, 0xc2c5d097, 0x1618fbe4, 0xf09131ef, 0x80173e25, 0x4eecd25c, 0xf05880a3, 0xfcd0e1aa, 0xb0be348f, 0x89353122, 0x49baf1b4, 0x9278de2c, 0x38832c11, 0x7263314d};
    uint32_t expected_output[32] = {0xab568cab, 0x8788884c, 0x73fc522c, 0x9089f061, 0xaa5f4254, 0xc0d32f7d, 0x3d58b41a, 0xa00a5263, 0x67534dde, 0xb5aa830e, 0xf718b281, 0xf99b3740, 0xeba63338, 0xadfe35b0, 0x041d57c0, 0x44d17209, 0x2a43baac, 0x432ac620, 0x206adf87, 0x7df68c65, 0xfe6ecab1, 0x973fe19d, 0xf6acfca0, 0xd197e90c, 0x6fcf86f7, 0x6ca237ba, 0xcb566216, 0x3237cd3b, 0xa9e65259, 0x13600ec6, 0xfb997871, 0x51aaa340};
    uint32_t size = 32;

    #elif EXP_TESTVECTOR == 3
    /* message */
    uint32_t X[32] = {0x22b3b2e5, 0x855e6eeb, 0xf97c2a24, 0x858f4dce, 0x18d08bc8, 0x2d779d59, 0x8e73afa3, 0xd662a4d1, 0x69b6a28a, 0x1dbf0a01, 0x7a091f53, 0xa6a24c08, 0x63f80a76, 0x909d0d22, 0xb9a92ee1, 0xd7fbd7d3, 0x9e2749f4, 0x5e91547f, 0xb01b886a, 0x160217b4, 0x5504f213, 0x777e690f, 0x5c41564b, 0x266fea1e, 0x14266d31, 0xd6406cff, 0x58ac507f, 0xf8104dd2, 0xefb99905, 0x6765a442, 0xc3fd3412, 0xa4d1cbd5};
    /* modulus */
    uint32_t M[32] = {0x2e4a4371, 0xdf1fb2bc, 0x6d4da708, 0xe68cfda7, 0x365c1a65, 0x45bf37df, 0x0dc8b4bd, 0xa151af5f, 0xf55bccc0, 0xfaa31a4f, 0xe5644738, 0x4effd6fa, 0x219a7372, 0x98488e9c, 0x90c4bd70, 0xaccbdd7d, 0xd49b83bf, 0x24975c3c, 0xa9061123, 0x13ecb4ae, 0x2ee652c0, 0x9838ef1e, 0x75a23d18, 0x6073e286, 0x52d23b61, 0x9a6a9dca, 0xfb06a3c6, 0x52c99fbc, 0xae5d54ec, 0xde92de5e, 0xa080e01d, 0xb10b8f96};
    uint32_t M_prime[32] = {0xfaf3e26f, 0x75f08430, 0x6d8fcf12, 0xe8c5ba4b, 0x9e264809, 0xd351418a, 0x9f8b9d41, 0x6859d6be, 0xed66f277, 0xc5437adc, 0xcdd683f4, 0xbacb7c0b, 0x94e36b0a, 0x2c324f0f, 0xaa2e9ba1, 0x4fa8e2c1, 0x9ca6dcbb, 0x7de571e6, 0x24dd5717, 0xde25014d, 0x543b8e37, 0x2f0c55fa, 0x2db1fb0f, 0x320ec939, 0xa8b449b8, 0x4205c15c, 0x69554bc8, 0x388bc4a8, 0xc677c17b, 0xaa37657a, 0x91784afa, 0x51c8e809};
    /* encryption exponent */
    //uint32_t E[5] = {0x5d48943e, 0x7086f845, 0x93049650, 0x8fefc1a2, 0xb9a3b3ae};
    //uint32_t exp_len = 160;
    uint32_t E[1] = {0x000ae417};
    uint32_t exp_len = 20;
    /* R mod N, and R^2 mod N, (R = 2^1024) */
    uint32_t R[32] = {0xd1b5bc8f, 0x20e04d43, 0x92b258f7, 0x19730258, 0xc9a3e59a, 0xba40c820, 0xf2374b42, 0x5eae50a0, 0x0aa4333f, 0x055ce5b0, 0x1a9bb8c7, 0xb1002905, 0xde658c8d, 0x67b77163, 0x6f3b428f, 0x53342282, 0x2b647c40, 0xdb68a3c3, 0x56f9eedc, 0xec134b51, 0xd119ad3f, 0x67c710e1, 0x8a5dc2e7, 0x9f8c1d79, 0xad2dc49e, 0x65956235, 0x04f95c39, 0xad366043, 0x51a2ab13, 0x216d21a1, 0x5f7f1fe2, 0x4ef47069};
    uint32_t R2[32] = {0x74aa5319, 0xc858a523, 0xb7606cc5, 0xe896dad3, 0xc46cff7c, 0xc81f66fb, 0x3888602d, 0x88a4e1b0, 0x01a1325d, 0x58e133b0, 0xee24e06c, 0x88913e20, 0xdb526dc0, 0x569160e0, 0xc675109f, 0xaa2ee84b, 0xea0736ad, 0xbbf724b4, 0x4dbd7ca7, 0xb6a3bb99, 0xba198811, 0x6ca21841, 0xe3939e0c, 0xd669f224, 0x3abd32e2, 0xc456f436, 0xd18062af, 0x8f62499e, 0xab9f57c1, 0x631df2a3, 0x9359aa23, 0xa6a24d2d};
    uint32_t expected_output[32] = {0xbe02a166, 0xe05fc340, 0x1c879fd9, 0xc4e09179, 0x60abbff5, 0x9f9bb209, 0x6af8aa61, 0xfa5e1c2d, 0x9fcf475a, 0xb3ff537b, 0xb35245b4, 0xfd212504, 0xe112e7d9, 0x5dbb498c, 0x167f7594, 0x0e83f430, 0x4cb08e2f, 0x7a10ef3d, 0x4f190a62, 0x01fa9c32, 0x0633db82, 0x19e8ddfd, 0x35e0008d, 0xc7aa4183, 0x33337b64, 0xfca5658d, 0x0134dde3, 0xb8a5b65a, 0x4a3324de, 0x86cfbed4, 0x1a039bb2, 0x1c9316ac};
    //uint32_t expected_output[32] = {0x5ed0a7f0, 0xc54d2a41, 0x760ef28e, 0x1a03f9c6, 0x2f60bb6a, 0x8a1d2ec9, 0x772f0a25, 0xaf2c399a, 0xce410b6b, 0x97e5e766, 0xcd2f9de0, 0xb00047d6, 0xe7928be6, 0x2396d8ea, 0xc28e0acd, 0x63721db5, 0xe6a24f6a, 0xeb9abe46, 0xc1403f63, 0x93c13e1e, 0x24597c25, 0x1db08463, 0x97396b63, 0x9b61f255, 0x5113de36, 0x8012aedd, 0x012d3417, 0xf8ee5346, 0x59eb004f, 0x2ad4d179, 0xa90d167d, 0x71cb343d};
    uint32_t size = 32;

    #elif EXP_TESTVECTOR == 4
    int32_t X[32] = {0x6bd93cbd, 0x2ebfb2c7, 0x7cf9e776, 0xe4187535, 0x66a33b10, 0x065afad6, 0x975f73d4, 0x496fb60b, 0x28529fbe, 0xc140401f, 0x7eeb31e2, 0xef45f639, 0xe5c0b738, 0xdb2ac5f3, 0x79802c83, 0x1f1b89c3, 0xbf7eaa58, 0xd45a55ba, 0xab819d74, 0xa6d3bd6f, 0x0482976d, 0xfec7eb1e, 0xf32906b7, 0x652d4084, 0x22033068, 0x36124322, 0x9f76d1a1, 0x6da7ec88, 0x5eacf0a4, 0xd1a8728e, 0xf8cc6ab0, 0xb02f6148};
    uint32_t E[1] = {0x0000b330};
    uint32_t exp_len =  16 ;
    uint32_t M[32] = {0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0x56369bca, 0x3c5ee883, 0xd47ce65d};
    uint32_t M_prime[32] = {0xd66e7c91, 0xc5b565a8, 0x3892fdf7, 0x31ccfc2c, 0x51f3c44e, 0x4eda9428, 0x882b0045, 0x40b44298, 0x4c14c80c, 0xf7a4f863, 0xe92fdb59, 0x689b1a21, 0x5bd4d3db, 0xd2021bfd, 0xa2173bab, 0xc9273af2, 0xd4e24d7c, 0x7ecc06b8, 0x93ad0a7e, 0x2848eb92, 0xa7686bf4, 0x85ac7173, 0x7f006423, 0x8b809826, 0x7e4c1de7, 0x8089306b, 0x99b4ca40, 0x3e8b96ea, 0x39f10350, 0x1f95753a, 0xe4500b0a, 0x25fb6099};
    uint32_t R[32] = {0x021cc471, 0x4554ee5e, 0xc37376c3, 0x4eaffdff, 0x062db445, 0x1ddd2a3c, 0x9353d693, 0x4671a9bd, 0x98c44c20, 0x409dd190, 0x3216d1ef, 0xa48f4f07, 0x43f50745, 0xd9eeeb6f, 0x6cfccb46, 0x99d88e88, 0xf1a07e0a, 0x840350b4, 0x7bee0fc5, 0x2fe8c066, 0x2cd138d1, 0xac42338d, 0x30064131, 0x65599856, 0x901c5873, 0xfd38b64b, 0x4ef68698, 0xa6f132d2, 0xb8a7cfb7, 0xa9c96435, 0xc3a1177c, 0x2b8319a2};
    uint32_t R2[32] = {0x26045bb8, 0xba193d95, 0xd20814ea, 0x19a75797, 0xfca712a6, 0x6b79d071, 0x3e3ddc88, 0x5221c132, 0x3486d53b, 0xc9d8e2d6, 0xaf41e254, 0xf196b1c4, 0x684ee3c1, 0xfa842770, 0xf24bd8f3, 0x5aade81a, 0x9e241aaf, 0xb124f0d0, 0xc3eab6fa, 0x3152f477, 0x5a3b6b5a, 0xc0b611fe, 0x8b7da09a, 0xe48206a5, 0xa49d1b4d, 0x1e325d7d, 0x7bc36905, 0x53c5c413, 0x42004279, 0x474987b3, 0x0d551915, 0x79cd4e0d};
    uint32_t expected_output[32] = {0x7b8b8b2b, 0xdf418dfd, 0xbc9b9a90, 0x9045168f, 0xf9693f5b, 0x08ae73eb, 0xb6e256c8, 0x703916b2, 0x15457095, 0x0f96215f, 0x6f55556f, 0xe82e4228, 0x02e95280, 0x2cb48c54, 0x8b2ff8c6, 0xa62d1978, 0x5a164faa, 0xebb41935, 0x7ded2df9, 0x6d1e6b7b, 0x3ee1749b, 0xf5748a36, 0x35688d90, 0xf73318f4, 0x1b508ad1, 0x8c821a1f, 0x05ab6332, 0x8cc46c1f, 0x2d33f2bb, 0x66ea8c0f, 0x326fcfb7, 0x2c844669};
    uint32_t size =  32 ;

    #elif EXP_TESTVECTOR == 5
    uint32_t X[32] = {0x6bd93cbd, 0x2ebfb2c7, 0x7cf9e776, 0xe4187535, 0x66a33b10, 0x065afad6, 0x975f73d4, 0x496fb60b, 0x28529fbe, 0xc140401f, 0x7eeb31e2, 0xef45f639, 0xe5c0b738, 0xdb2ac5f3, 0x79802c83, 0x1f1b89c3, 0xbf7eaa58, 0xd45a55ba, 0xab819d74, 0xa6d3bd6f, 0x0482976d, 0xfec7eb1e, 0xf32906b7, 0x652d4084, 0x22033068, 0x36124322, 0x9f76d1a1, 0x6da7ec88, 0x5eacf0a4, 0xd1a8728e, 0xf8cc6ab0, 0xb02f6148};
    uint32_t E[1] = {0x00000003};
    uint32_t exp_len =  2 ;
    uint32_t M[32] = {0x3b6021e5, 0x134c079f, 0xfde33b8f, 0xbaab11a1, 0x3c8c893c, 0xb1500200, 0xf9d24bba, 0xe222d5c3, 0x6cac296c, 0xb98e5642, 0x673bb3df, 0xbf622e6f, 0xcde92e10, 0x5b70b0f8, 0xbc0af8ba, 0x26111490, 0x930334b9, 0x66277177, 0x0e5f81f5, 0x7bfcaf4b, 0x8411f03a, 0xd0173f99, 0xd32ec72e, 0x53bdcc72, 0xcff9bece, 0x9aa667a9, 0x6fe3a78c, 0x02c749b4, 0xb1097967, 0x590ecd2d, 0x47583048, 0xd6369bca};
    uint32_t M_prime[32] = {0xb7bfcc13, 0x913284a2, 0xdda7b6f2, 0x7a5c8583, 0x709ca502, 0xaa20b65c, 0xe603ebeb, 0x370f8de1, 0x6e6a026e, 0xd531c566, 0x1271e3eb, 0x732d0aed, 0x5f44d582, 0x3c5ebd20, 0x4625fb34, 0xbffb3ff7, 0x28b98ae5, 0x2fbac94d, 0xc26bafc9, 0xcae25e12, 0xb43b5053, 0x56971c37, 0x4bbeb19d, 0x0a85b251, 0x11df4432, 0xb449f6bb, 0x04e65bfb, 0x485edf78, 0x5f3c3876, 0xb7bbe9c9, 0x0734e9ad, 0x4a415b38};
    uint32_t R[32] = {0xc49fde1b, 0xecb3f860, 0x021cc470, 0x4554ee5e, 0xc37376c3, 0x4eaffdff, 0x062db445, 0x1ddd2a3c, 0x9353d693, 0x4671a9bd, 0x98c44c20, 0x409dd190, 0x3216d1ef, 0xa48f4f07, 0x43f50745, 0xd9eeeb6f, 0x6cfccb46, 0x99d88e88, 0xf1a07e0a, 0x840350b4, 0x7bee0fc5, 0x2fe8c066, 0x2cd138d1, 0xac42338d, 0x30064131, 0x65599856, 0x901c5873, 0xfd38b64b, 0x4ef68698, 0xa6f132d2, 0xb8a7cfb7, 0x29c96435};
    uint32_t R2[32] = {0xdbc1f8f5, 0xf0b21422, 0x0d5ce12d, 0x8bf6674a, 0x79da5d6c, 0x8b4c29bd, 0xd85013c5, 0xcb075991, 0x2d1b80ff, 0x1f7c5324, 0x9748937f, 0x66816f22, 0x7b5718bb, 0x81e6a3f3, 0xa2224052, 0x7c5571e1, 0x0425d5c9, 0x429c93b3, 0x82cdbd69, 0x26200729, 0x8d9e7da4, 0x0360fe11, 0x8cf166a3, 0xafcf3310, 0x00d3f832, 0x10bc759b, 0x310def28, 0x4e09dc91, 0x3508c858, 0xd2b5d271, 0x262f767d, 0x7a23eae8};
    uint32_t expected_output[32] = {0x2ce21a20, 0xcb5b9814, 0x90605b33, 0x5af59716, 0x4f07ec4e, 0x64ea8d10, 0xde81ea17, 0xc0d2aa89, 0x95da6afe, 0x0b67fed5, 0x4185b338, 0xa908a2ec, 0x82d658a6, 0x1bda310b, 0xbe5edaf9, 0xffd21728, 0xf160971e, 0xd5579fae, 0x71453ff5, 0x725784c3, 0x108131a3, 0xca63c353, 0x798a79c7, 0xf07786b1, 0x134f0a9a, 0xad1972c0, 0x28c52783, 0x31a1df14, 0xa9a52606, 0xef06cd59, 0x226a15b4, 0x6d039b24};
    uint32_t size =  32 ;

    #elif EXP_TESTVECTOR == 6
    uint32_t X[32] = {0x5204a0f4, 0x471df4bc, 0x2943dabc, 0xb33cf03c, 0x6c3700c0, 0x9c2e40a2, 0x6adfcf1e, 0x6ea31cc6, 0x54640571, 0x251b5eac, 0x783b7589, 0x473fe47b, 0xe36d9e78, 0x57153d0b, 0x8696b918, 0x1a4fd6c0, 0x4c3a0ab4, 0xd663800e, 0xe6c7efa5, 0xe773fa73, 0x98419280, 0x65441264, 0x6a749096, 0x320a57ae, 0xbfe4daaa, 0x229ec3a6, 0x60a6aee8, 0x68dac070, 0xb3d00628, 0xd7a3120a, 0xb02aa62c, 0x90f35c6d};
    uint32_t E[1] = {0x00000003};
    uint32_t exp_len =  3 ;
    uint32_t M[32] = {0x0ef31747, 0xf3d8b0d7, 0xa8de9738, 0xece35114, 0xe0643aba, 0x46dd62bd, 0xc2005261, 0xe1e83167, 0xa50b0b7c, 0xb6c38903, 0x609f2ad9, 0x310a9fc2, 0x5bee620f, 0x1ff62a17, 0x6ff4d2bd, 0x10e5d3fb, 0xe4df395b, 0xa78de346, 0x10213dc3, 0xea1ac1ed, 0xd458eb04, 0xe438c468, 0x28800b75, 0x02ec2efe, 0xd24f68c9, 0xb8e75ae3, 0x9f7c00eb, 0xcb45d78b, 0x38ec9502, 0x474556ce, 0x0cf424ed, 0xe4f390d5};
    uint32_t M_prime[32] = {0x154e9d89, 0xfd21221c, 0xea40621f, 0x9d2592ca, 0xdb2dfd37, 0xa1b3cca1, 0xd0d37e5b, 0x519b0a73, 0x332094ae, 0x2c6de6a8, 0x5baabe3e, 0xb58420e1, 0xd6198fb8, 0x5fd0a147, 0x685f43bd, 0x463668d0, 0xe203c9e0, 0x45d53656, 0x2413e640, 0x54bc3a78, 0x82fcabaa, 0x02808516, 0x92876bb3, 0x27ad12d7, 0x0d03d700, 0x147dcbd1, 0x47f0325f, 0x7ad15049, 0x26b7ce29, 0xcda191e3, 0x5ce38f4d, 0x2449ee60};
    uint32_t R[32] = {0xf10ce8b9, 0x0c274f28, 0x572168c7, 0x131caeeb, 0x1f9bc545, 0xb9229d42, 0x3dffad9e, 0x1e17ce98, 0x5af4f483, 0x493c76fc, 0x9f60d526, 0xcef5603d, 0xa4119df0, 0xe009d5e8, 0x900b2d42, 0xef1a2c04, 0x1b20c6a4, 0x58721cb9, 0xefdec23c, 0x15e53e12, 0x2ba714fb, 0x1bc73b97, 0xd77ff48a, 0xfd13d101, 0x2db09736, 0x4718a51c, 0x6083ff14, 0x34ba2874, 0xc7136afd, 0xb8baa931, 0xf30bdb12, 0x1b0c6f2a};
    uint32_t R2[32] = {0x8f64843f, 0x5175009b, 0x19d49251, 0x9db2b2bc, 0x01895be9, 0x791a5d68, 0xf27e294d, 0xcdd27b1e, 0x31f7003c, 0x92caf811, 0x5cbce177, 0xec50ef16, 0x32570b0e, 0x2f099ce6, 0xb7899400, 0x5171f544, 0x9fde17a7, 0x8a9f7b58, 0x3c6448df, 0x3955c76c, 0xb3997a51, 0x225212bf, 0x3d4d276b, 0x7eb5f44e, 0x8dcdac09, 0x7c9a75cb, 0xc84bef22, 0x017050c7, 0xe3b95aae, 0x5dba2812, 0x2f27c903, 0x8ad3e22c};
    uint32_t expected_output[32] = {0x605d5def, 0x3bd4b0bb, 0x5e4f8e7d, 0x58c4ba04, 0x9f51fc53, 0xd2c7171a, 0x3f6ebaba, 0x4936915a, 0xcb2b8c88, 0x5c3b2b45, 0x35f3331b, 0x0022c7b3, 0xd7f12aa0, 0x1ddb9c32, 0x0a3cdfa7, 0x203142ec, 0x76592cca, 0x17cd037e, 0x7c60c0b5, 0x57723806, 0x8cd291c2, 0xc4111f92, 0x9be3cd93, 0x5610a1a7, 0x3bd0c778, 0x48b723b5, 0x2034c6e4, 0x79c82cfe, 0xad6997ed, 0x85d25a75, 0x54c4b7ea, 0x8aab9d60};
    uint32_t size =  32 ;

    /* size 39 seed 2017 */
    #elif EXP_TESTVECTOR == 7
    uint32_t X[39] = {0x53f9c740, 0x5a4572aa, 0xe3bc243f, 0x0a11ded0, 0x3c6773b5, 0x32f9bf68, 0xe5edac83, 0xe00d743e, 0x9de79141, 0x90b70941, 0x335c342b, 0xd8261b0f, 0x5d6b6996, 0x436c18b8, 0x2e4eda55, 0xcc75cafd, 0x790c12fd, 0x111fb213, 0x34ce70a9, 0xc3c26c09, 0x4315251c, 0xe2927779, 0xcbe8ef75, 0xec1eb181, 0x734a4d33, 0x91674d16, 0x7303e7e9, 0x2f6d5bce, 0xa993a9de, 0x595dc846, 0xfb5c677b, 0x239b4443, 0x5fe4d421, 0x472621fc, 0x5cfa9f68, 0x4ec54058, 0x66c119ac, 0x0134fd0e, 0x8b457c8c};
    uint32_t E[39] = {0x29155acd, 0x3b95d1cb, 0x18004090, 0x9f1776c3, 0xa363c5c6, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000};
    uint32_t exp_len =  160 ;
    uint32_t M[39] = {0x0b265b63, 0xd497aaee, 0xb2c57169, 0x0ab289ed, 0x7cbfac0e, 0x67946aa2, 0x11a4c617, 0xe5a7aafa, 0xa4cb23d9, 0x1e5b3af8, 0x63c9f04f, 0x0b5a5ac8, 0xcd502fb6, 0x46eb4ff4, 0x5984c4fe, 0xb15e5303, 0x16488f50, 0xda71b430, 0xe31772d7, 0xa4272020, 0x96409d07, 0x82b65dc7, 0x0ee664d0, 0xd97b4c43, 0x6f6b7177, 0xfdaeeff5, 0xd5b43e17, 0x31276d2d, 0x48e4d8b5, 0xa14fe499, 0x7dc28fb1, 0x8ab4be20, 0x0f31a3c8, 0xfa52d166, 0x8c266883, 0x37cbcabc, 0x9be2adda, 0xc00cc08b, 0x89bb5336};
    uint32_t M_prime[39] = {0x784201b5, 0x7dc75f6f, 0x81b9129c, 0x016504ef, 0x21c64796, 0xe5080e73, 0x725a3a3f, 0x4ded71fe, 0xc3d4d0a4, 0x24fda544, 0xafcfe452, 0xab06cebc, 0xd35ced5c, 0x5c4e9365, 0x28756a9b, 0x5c6ea23f, 0xe8147ff1, 0x35050013, 0x0d27892a, 0x085dbef8, 0x4bc783ff, 0x83af3bd6, 0x6d589089, 0xa309985b, 0x7de0e684, 0x9095239e, 0x636785bc, 0x67329996, 0x61918f4d, 0xdb554ef7, 0xe8868b02, 0x9b6c6017, 0x4381ef39, 0x5b347ab7, 0xe8117309, 0xedea9f06, 0x4ac99f2e, 0x48b13298, 0x58d388fc};
    uint32_t R[39] = {0xf4d9a49d, 0x2b685511, 0x4d3a8e96, 0xf54d7612, 0x834053f1, 0x986b955d, 0xee5b39e8, 0x1a585505, 0x5b34dc26, 0xe1a4c507, 0x9c360fb0, 0xf4a5a537, 0x32afd049, 0xb914b00b, 0xa67b3b01, 0x4ea1acfc, 0xe9b770af, 0x258e4bcf, 0x1ce88d28, 0x5bd8dfdf, 0x69bf62f8, 0x7d49a238, 0xf1199b2f, 0x2684b3bc, 0x90948e88, 0x0251100a, 0x2a4bc1e8, 0xced892d2, 0xb71b274a, 0x5eb01b66, 0x823d704e, 0x754b41df, 0xf0ce5c37, 0x05ad2e99, 0x73d9977c, 0xc8343543, 0x641d5225, 0x3ff33f74, 0x7644acc9};
    uint32_t R2[39] = {0x44cded63, 0x03c58ebf, 0x7c63cc35, 0x01ab5086, 0x5fc7c176, 0xae5aca7d, 0xa7044265, 0x165a717f, 0xb40f76a2, 0xc67b0d85, 0xd98836a2, 0xe939356c, 0xbfb937bb, 0x548f1cba, 0xee69cb85, 0xb4a2e513, 0xd49f1b6b, 0xc2835611, 0xc804a349, 0x5ba81fed, 0x2adfc973, 0x9e9b415a, 0x2f364409, 0x044cee50, 0xbbd41614, 0xac954633, 0x59a71fb3, 0xf5aeb652, 0x49778fa6, 0xef768939, 0xb7c20983, 0x41332a46, 0x07d43c7d, 0xdf915bf3, 0x92e091ff, 0x47f43603, 0x0439f4bb, 0xd831c9df, 0x79061d0d};
    uint32_t expected_output[39] = {0x3ac80798, 0xd15b6275, 0xf60c399e, 0xbdc1dc57, 0x8bfa3d19, 0x3cc82091, 0x2a40ea25, 0xa4a1294b, 0x9d6e6f0e, 0x2594cb09, 0xcda21daa, 0x411cdd0f, 0xb5a9df7f, 0x1a464b2f, 0x396534ff, 0xa785d6dd, 0xdeb8d7d5, 0x03a3c1c1, 0x1c18d9c9, 0x34fb1caf, 0xd2b6fa9e, 0xf9f339fa, 0xaf77f3bb, 0x75508e28, 0x9cd39f58, 0xd2074820, 0xfdeb1050, 0x3ce0a76f, 0xb37fab20, 0x9e4773fa, 0x6b02a6f3, 0x7143e1bd, 0xedd4465f, 0x90139041, 0xb74b26da, 0xe3fd229c, 0x92a42e48, 0x02ebabf8, 0x64ea78da};
    uint32_t size =  39 ;

    /* RSA encryption part */
    #elif EXP_TESTVECTOR == 8
    uint32_t X[39] = {0x12345678, 0x12345678, 0x12345678, 0x12345678, 0x12345678, 0};
    uint32_t E[1] = {0x00010001};
    uint32_t exp_len =  32 ;
    uint32_t M[39] = {0x0555df83, 0x5f4cf186, 0x41a74eab, 0x555d4665, 0xa85b8f09, 0xd41c5091, 0x2251f04b, 0xb4c1b0b0, 0xf58f1563, 0x87e3be3b, 0x475120f2, 0xcd2faac9, 0xb6a53cda, 0x91da4ab2, 0xf6b47377, 0x99b511ad, 0xc1aa3e02, 0x66156ad9, 0x00b62491, 0xd25d048c, 0xaa5c77e1, 0x0c005883, 0x189f583d, 0xf9b19c87, 0x8674c144, 0xbc619e38, 0xa6e53c26, 0xee532d31, 0x012b534e, 0xda52fc8c, 0xefaf19a7, 0x099e31cb, 0x5e151b21, 0x421307c2, 0x03afe93c, 0x2cb52503, 0x59a36580, 0x03e92f99, 0xb2209191};
    uint32_t M_prime[39] = {0xd4e858d5, 0xe0e86cbf, 0x3168a7c2, 0x46096eb1, 0x4fd03415, 0xf133a9c5, 0x9af4d222, 0xf999034e, 0x96177585, 0x4b9e730d, 0xe01d3389, 0xbe60865c, 0x7cd2877e, 0x524405d7, 0x6485feeb, 0x11a0e3b0, 0x2a0fbf19, 0x8c2a2b78, 0x690fc96e, 0x79ab9bfd, 0x2a2057ce, 0xffa119d4, 0x60b48475, 0xd7b41f4d, 0xb0b4693a, 0x7e03503e, 0x49684888, 0x8a07f270, 0xc5fbea68, 0x8676c7ec, 0x6fc64ee3, 0x8776f2da, 0x7729d7ca, 0x616b86df, 0x7a010fd4, 0xaa154ce9, 0x198d25ae, 0xc028ccdd, 0x3b71bdbd};
    uint32_t R[39] = {0xfaaa207d, 0xa0b30e79, 0xbe58b154, 0xaaa2b99a, 0x57a470f6, 0x2be3af6e, 0xddae0fb4, 0x4b3e4f4f, 0x0a70ea9c, 0x781c41c4, 0xb8aedf0d, 0x32d05536, 0x495ac325, 0x6e25b54d, 0x094b8c88, 0x664aee52, 0x3e55c1fd, 0x99ea9526, 0xff49db6e, 0x2da2fb73, 0x55a3881e, 0xf3ffa77c, 0xe760a7c2, 0x064e6378, 0x798b3ebb, 0x439e61c7, 0x591ac3d9, 0x11acd2ce, 0xfed4acb1, 0x25ad0373, 0x1050e658, 0xf661ce34, 0xa1eae4de, 0xbdecf83d, 0xfc5016c3, 0xd34adafc, 0xa65c9a7f, 0xfc16d066, 0x4ddf6e6e};
    uint32_t R2[39] = {0x6cbe9363, 0xe4d6e504, 0x9153b727, 0x75aa16fa, 0xa92e3c8a, 0x907091ee, 0x2ba3f8bd, 0xaeed8330, 0x16996ca8, 0x13139bc8, 0x6ab357d1, 0x3c7e0d8f, 0x3d7fe4c9, 0x09765146, 0x08e73b82, 0xa09e541f, 0x1e8bbae5, 0x30600a64, 0x91b8e7bb, 0xa153f4cb, 0x0bcc488d, 0x0ac447c3, 0xc4d37a5e, 0x6236fae8, 0x24860d33, 0xb4f3e761, 0x3e87dcfd, 0x55ccdf9c, 0xbfc00877, 0xa19c5df4, 0x66f01bfb, 0x3d4ceff6, 0xcc503607, 0x7657b7b6, 0x54557122, 0x0c1da4ba, 0x820000fa, 0x4dab3595, 0x9eb00c06};
    uint32_t expected_output[39] = {0x150b1bb8, 0x90269be2, 0xf96faeee, 0xfd34dd87, 0xf123443f, 0xb36c31b5, 0x0ac3c64e, 0xe0d66166, 0x3bc5365b, 0x9c71e551, 0x81fa3d84, 0xe4baa99a, 0x03bb9b46, 0x3ea2dfe4, 0x4a9caf3e, 0xde7a1b3e, 0x2f9e3cc2, 0x0097cf91, 0xf3127d4a, 0x5b165ca1, 0x93da5eaf, 0x9429ae56, 0xfac4235e, 0xa62d7af3, 0x4fdd2712, 0x2488b77f, 0x660fda9c, 0x26292dc4, 0xc7e79565, 0x361f25dc, 0xc82f7861, 0x4d11caf1, 0x75bb9956, 0x5cdc2dd6, 0x9b1a3db9, 0x157c270b, 0x7ad5f0fb, 0x3a6cd1ea, 0x5b8c66fa};
    uint32_t size =  39 ;

    /* RSA decryption part */
    #elif EXP_TESTVECTOR == 9
    uint32_t X[39] = {0x150b1bb8, 0x90269be2, 0xf96faeee, 0xfd34dd87, 0xf123443f, 0xb36c31b5, 0x0ac3c64e, 0xe0d66166, 0x3bc5365b, 0x9c71e551, 0x81fa3d84, 0xe4baa99a, 0x03bb9b46, 0x3ea2dfe4, 0x4a9caf3e, 0xde7a1b3e, 0x2f9e3cc2, 0x0097cf91, 0xf3127d4a, 0x5b165ca1, 0x93da5eaf, 0x9429ae56, 0xfac4235e, 0xa62d7af3, 0x4fdd2712, 0x2488b77f, 0x660fda9c, 0x26292dc4, 0xc7e79565, 0x361f25dc, 0xc82f7861, 0x4d11caf1, 0x75bb9956, 0x5cdc2dd6, 0x9b1a3db9, 0x157c270b, 0x7ad5f0fb, 0x3a6cd1ea, 0x5b8c66fa};
    uint32_t E[39] = {0xb5d1d3c1, 0x0655f903, 0x41bf5b6e, 0x2bbd6097, 0xaab78801, 0xac02bca1, 0x08ad015a, 0xad3f5ffb, 0xdcc36a55, 0xfd113fc5, 0x4668a9bc, 0xc2c5d902, 0x78c0bd3f, 0x9901cbcb, 0xd45171e5, 0xcbc7bd24, 0x22cd4bda, 0x9ec32cab, 0xc0e738ff, 0x04ebf9d0, 0x92b00d5f, 0x280d15cd, 0x4f73aef7, 0x9e60e142, 0x73d8fd36, 0x9ff4ecc0, 0x505d10a4, 0xf700e6c5, 0xc4b03030, 0xd98913d4, 0xdb4d5b81, 0xadc9c551, 0xaf91becc, 0xd44c46d9, 0xc635969c, 0x42a2f610, 0x03d2b071, 0xd124dd01, 0x3c13f004};
    uint32_t exp_len =  1248 ;
    uint32_t M[39] = {0x0555df83, 0x5f4cf186, 0x41a74eab, 0x555d4665, 0xa85b8f09, 0xd41c5091, 0x2251f04b, 0xb4c1b0b0, 0xf58f1563, 0x87e3be3b, 0x475120f2, 0xcd2faac9, 0xb6a53cda, 0x91da4ab2, 0xf6b47377, 0x99b511ad, 0xc1aa3e02, 0x66156ad9, 0x00b62491, 0xd25d048c, 0xaa5c77e1, 0x0c005883, 0x189f583d, 0xf9b19c87, 0x8674c144, 0xbc619e38, 0xa6e53c26, 0xee532d31, 0x012b534e, 0xda52fc8c, 0xefaf19a7, 0x099e31cb, 0x5e151b21, 0x421307c2, 0x03afe93c, 0x2cb52503, 0x59a36580, 0x03e92f99, 0xb2209191};
    uint32_t M_prime[39] = {0xd4e858d5, 0xe0e86cbf, 0x3168a7c2, 0x46096eb1, 0x4fd03415, 0xf133a9c5, 0x9af4d222, 0xf999034e, 0x96177585, 0x4b9e730d, 0xe01d3389, 0xbe60865c, 0x7cd2877e, 0x524405d7, 0x6485feeb, 0x11a0e3b0, 0x2a0fbf19, 0x8c2a2b78, 0x690fc96e, 0x79ab9bfd, 0x2a2057ce, 0xffa119d4, 0x60b48475, 0xd7b41f4d, 0xb0b4693a, 0x7e03503e, 0x49684888, 0x8a07f270, 0xc5fbea68, 0x8676c7ec, 0x6fc64ee3, 0x8776f2da, 0x7729d7ca, 0x616b86df, 0x7a010fd4, 0xaa154ce9, 0x198d25ae, 0xc028ccdd, 0x3b71bdbd};
    uint32_t R[39] = {0xfaaa207d, 0xa0b30e79, 0xbe58b154, 0xaaa2b99a, 0x57a470f6, 0x2be3af6e, 0xddae0fb4, 0x4b3e4f4f, 0x0a70ea9c, 0x781c41c4, 0xb8aedf0d, 0x32d05536, 0x495ac325, 0x6e25b54d, 0x094b8c88, 0x664aee52, 0x3e55c1fd, 0x99ea9526, 0xff49db6e, 0x2da2fb73, 0x55a3881e, 0xf3ffa77c, 0xe760a7c2, 0x064e6378, 0x798b3ebb, 0x439e61c7, 0x591ac3d9, 0x11acd2ce, 0xfed4acb1, 0x25ad0373, 0x1050e658, 0xf661ce34, 0xa1eae4de, 0xbdecf83d, 0xfc5016c3, 0xd34adafc, 0xa65c9a7f, 0xfc16d066, 0x4ddf6e6e};
    uint32_t R2[39] = {0x6cbe9363, 0xe4d6e504, 0x9153b727, 0x75aa16fa, 0xa92e3c8a, 0x907091ee, 0x2ba3f8bd, 0xaeed8330, 0x16996ca8, 0x13139bc8, 0x6ab357d1, 0x3c7e0d8f, 0x3d7fe4c9, 0x09765146, 0x08e73b82, 0xa09e541f, 0x1e8bbae5, 0x30600a64, 0x91b8e7bb, 0xa153f4cb, 0x0bcc488d, 0x0ac447c3, 0xc4d37a5e, 0x6236fae8, 0x24860d33, 0xb4f3e761, 0x3e87dcfd, 0x55ccdf9c, 0xbfc00877, 0xa19c5df4, 0x66f01bfb, 0x3d4ceff6, 0xcc503607, 0x7657b7b6, 0x54557122, 0x0c1da4ba, 0x820000fa, 0x4dab3595, 0x9eb00c06};
    uint32_t expected_output[39] = {0x12345678, 0x12345678, 0x12345678, 0x12345678, 0x12345678, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000};
    uint32_t size =  39 ;



    #else /* EXP_TESTVECTOR */
    uint32_t X[16] = {0x324a69cd, 0x10e2ab7b, 0xfa9a1c77, 0x9ab7195e, 0xc2d0c1d1, 0xa5bb1695, 0xa57c7cd2, 0xedfc2301, 0x9e6942fb, 0x94c9a459, 0x76b80084, 0x6e801595, 0x1c41d0fc, 0x1e95b7da, 0x165612f5, 0xda43b766};
    uint32_t M[16] = {0xde86c839, 0x9b0d92a9, 0x517aecfb, 0x9ccd20b0, 0x3bb90c15, 0x6e4a2257, 0x026b43a1, 0xcd464a6f, 0xc7a08980, 0xf1d3e53b, 0x0e70fe4c, 0x0d240f24, 0x77b26e20, 0x13309160, 0xf3cc45c8, 0x853b02a0};
    uint32_t M_prime[16] = {0xa92159f7, 0xff2f17b0, 0x92037635, 0x5aa21e5b, 0x00430979, 0x59f3596d, 0x200fb85a, 0xe1d61ef7, 0x90a25caf, 0xb8332fab, 0xab09516d, 0xe09f34d1, 0x422e4095, 0x86b9e133, 0x5411c1d8, 0x5a84bb6b};
    uint32_t E[16] = {0x000000cb};
    uint32_t exp_len = 8;
    uint32_t R[16] = {0x217937c7, 0x64f26d56, 0xae851304, 0x6332df4f, 0xc446f3ea, 0x91b5dda8, 0xfd94bc5e, 0x32b9b590, 0x385f767f, 0x0e2c1ac4, 0xf18f01b3, 0xf2dbf0db, 0x884d91df, 0xeccf6e9f, 0x0c33ba37, 0x7ac4fd5f};
    uint32_t R2[16] = {0xd282639e, 0x1e537592, 0x455d874a, 0xba3fc0a1, 0xeae56c27, 0x5e2df8a9, 0x2015a742, 0x202c3b53, 0x0a5ef113, 0x88383068, 0xd94aa778, 0x4ec3fb6b, 0xedb60471, 0x611bc477, 0xf13dd00a, 0x084a3e64};
    uint32_t expected_output[16] = {0x60af6946, 0x4f537202, 0x6a4adcb3, 0xc98bda64, 0x8de4492f, 0xf2460f42, 0xc86d4a36, 0xe0a724ad, 0x3c158451, 0x6143fe63, 0x1a62dd8b, 0xdaf53676, 0xcda026e5, 0x6c9d9476, 0xe250d3fa, 0x20fb6cab};
    uint32_t size = 16;
    #endif /* TESTVECTOR */

    uint32_t output[39];
    printf("Testing exponentiation\r\n");

    printf("Printing expected output: \r\n");
    printArray(expected_output, size);


    mod_exp(X, E, exp_len, M, M_prime, R, R2, size, output);

    printf("Printing exponentiation result: \r\n");
    printArray(output, size);

    if (memcmp(output, expected_output, size) != 0) {
        fprintf(stderr, "Exponentiation failed\r\n");
        abort();
    }
    return 0;
}

int test_padding() {
    #define PAD_TESTVECTOR 2

    #if PAD_TESTVECTOR == 1
    uint32_t input_byte_size = 8;
    uint32_t input[2] = {0x01234567, 0xffffffff};
    int output_size = 4;
    uint32_t output_byte_size = 16;
    uint32_t expected_output[4] = {0x01234567, 0xffffffff, 0x08080808, 0x08080808};

    #elif PAD_TESTVECTOR == 2
    uint32_t input_byte_size = 4;
    uint32_t input[1] = {0x01234567};
    int output_size = 4;
    uint32_t output_byte_size = 16;
    uint32_t expected_output[4] = {0x01234567, 0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c};

    #else /*PAD_TESTVECTOR*/
    uint32_t input_byte_size = 1;
    uint32_t input[1] = {0xff000000};
    int output_size = 1;
    uint32_t output_byte_size = 4;
    uint32_t expected_output[1] = {0xff030303};
    #endif /*PAD_TESTVECTOR*/

    uint32_t output[4];
    printf("Testing padding");

    printf("Printing expected output: \r\n");
    printArray(expected_output, output_size);

    addPadding(output, input, input_byte_size, output_byte_size);

    printf("Printing padding result: \r\n");
    printArray(output, output_size);

    if (memcmp(output, expected_output, output_size) != 0) {
        fprintf(stderr, "Padding failed\r\n");
        abort();
    }
    return 0;
}

int test_handshake() {
    uint32_t g_x[32];
    printf("Testing handshake protocol\r\n");

    printf("Master handshake step 1:\r\n");
    printf("Printing expected output:\r\n");
    printArray(yA, 32);

    master_handshake_1(g_x, xA, 160);

    printf("Printing master handshake step 1 output:\r\n");
    printArray(g_x,32);

    if (memcmp(g_x, yA, 32) != 0) {
        fprintf(stderr, "Master handshake step 1 failed!\r\n");
        abort();
    }
    return 0;
}


int test_datagram() {

    uint32_t iv[3] = {1,0};
    uint32_t counter = 0;
    uint32_t key[4] = {1,0};
    uint32_t to_send_buffer[8] = {0,1,2,3,4,5,6,7};
    int N_blocks_send = 2;
    int N_blocks_receive = 4;
    uint32_t sending_buffer[16];
    uint32_t receive_buffer[8];

    printf("Testing datagram protocol\r\n");
    master_datagram(sending_buffer,to_send_buffer,N_blocks_send,iv,counter,key);
    slave_datagram(receive_buffer,sending_buffer,N_blocks_receive,iv,counter,key);

    if (memcmp(receive_buffer, to_send_buffer, 8) != 0) {
        fprintf(stderr, "Datagram protocol failed\r\n");
        printf("Printing expected output:\r\n");
        printArray(to_send_buffer,8);
        printf("Printing received output:\r\n");
        printArray(receive_buffer,8);
        abort();
    }
    else{
        printf("Data transmission correct! \r\n");
    }
    return 0;
}

int test_fsm_data_transmission() {
    start_session = 1;
    transmit_buffer = 1;
    run_master();
    printArray(input_buffer, 4);
    printArray(output_buffer, 4);
    if (memcmp(input_buffer, output_buffer, 4) != 0) {
        fprintf(stderr, "FSM data transmission failed!\r\n");
        abort();
    }
    return 0;
}

int test_rsa_encoded_message() {
    uint8_t test_hash[32] = {0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04};
    uint8_t expected_output[64] = {0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x30, 49, 0x30, 13, 0x06, 9, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0, 0x04, 32,
                                    0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04, 0x01, 0x02, 0x03, 0x04};
    uint8_t output[64];
    printf("Testing RSA encoded message\r\n");
    rsa_encoded_message(output, test_hash, 64);
    if (memcmp(output, expected_output, 64) != 0) {
        fprintf(stderr, "RSA encoded message failed!\r\n");
        abort();
    }
    return 0;
}

int test_rsa() {
    #define RSA_TESTVECTOR 2

    #if RSA_TESTVECTOR == 1
    uint32_t test_input[39] = {0x12345678, 0x12345678, 0x12345678, 0x12345678, 0x12345678, 0};
    #else /* RSA_TESTVECTOR */
    uint32_t test_input[39] = {0x2ad311b3, 0x7c2838c5, 0xe5077058, 0x4f5ae87f, 0xddecca6e, 0x2ec861f6, 0x79dc00cd, 0xce12c988, 0x464c72cc, 0x9eba8a87, 0xa494a5f6, 0x90ec34b0, 0x2c463306, 0xfee91a3d, 0x925ff5f3, 0xf767ed57, 0x1365f781, 0x0cafa0b9, 0xd3d83746, 0x1237b13f, 0x2ff22747, 0xdf512860, 0x1d7a14f4, 0xa6f73415, 0xb7e3aea4, 0x06adba10, 0x6c2530b4, 0xbb50cb85, 0x98da9e7b, 0x9d3d2f3f, 0x0c4b47f2, 0xe132eb0d, 0xd3399ae3, 0x94575355, 0x2a757f02, 0xc36b2d8b, 0x18221ebf, 0xf6505434, 0xb06fb08b};
    #endif /* RSA_TESTVECTOR */

    uint32_t encrypted[39];
    uint32_t output[39];
    printf("Testing RSA: \r\n");

    printf("Printing test input:\r\n");
    printArray(test_input, 39);

    mod_exp(test_input, es, 20, rsa_modulus, r_prime, R_rsa, R2_rsa, 39, encrypted);
    mod_exp(encrypted, ds, 1248, rsa_modulus, r_prime, R_rsa, R2_rsa, 39, output);

    printf("Printing output: \r\n");
    printArray(output, 39);

    if (memcmp(test_input, output, 39) != 0) {
        fprintf(stderr, "RSA failed!\r\n");
        abort();
    }
    return 0;
}

int test_data_exchange(){
    uint32_t gx[32];
    /* x for testing from global variables*/
    uint32_t *x = xA;
    uint32_t gy[32];
    uint32_t slave_signature[40];
    uint32_t key_slave[4];
    uint32_t IV[3] = {1,0};
    uint32_t *y = xB;
    uint32_t master_signature[40];
    int alpha_verif;
    uint32_t key_master[4];
    int beta_verif;

    uint32_t counter = 0;
    uint32_t to_send_buffer[8] = {0,1,2,3,4,5,6,7};
    int N_blocks_send = 2;
    int N_blocks_receive = 4;
    uint32_t sending_buffer[16];
    uint32_t receive_buffer[8];

    printf("Testing a full exchange: handshake + data \n");
    printf("Step one: master calculates gx from a random x \r\n");
    master_handshake_1(gx,x,160);

    printf("Step two: slave calculates gy from a random y \n");
    printf("Slave calculates key from gx and gy \r\n");
    slave_handshake_1(gy,slave_signature,key_slave,gx,IV,y,160);

    printf("Step three: master calculates key from gx and gy \n");
    printf(" Master also checks for the correct signature \r\n");
    alpha_verif = master_handshake_2(master_signature, key_master,IV,gy,slave_signature,x,160,gx);
    if (alpha_verif == 0) {
       printf("Alpha differs from alpha_prime!\r\n");
       abort();
    }

    printf("Step four: slave checks master signature \r\n");
    beta_verif = slave_handshake_2(master_signature, key_slave, gx, gy, IV);
    if (beta_verif == 0) {
       printf("Beta differs from beta_prime!\r\n");
       abort();
    }

    printf("Printing master key:\r\n");
    printArray(key_master,4);
    printf("Printing slave key:\r\n");
    printArray(key_slave,4);
    if (memcmp(key_master, key_slave, 4) != 0) {
        fprintf(stderr, "Both keys are different \r\n");
        abort();
    }
    else{
        printf("Both keys are the same! \r\n");
    }

    printf("Step five: transmission of data \r\n");
    master_datagram(sending_buffer,to_send_buffer,N_blocks_send,IV,counter,key_master);
    slave_datagram(receive_buffer,sending_buffer,N_blocks_receive,IV,counter,key_slave);

    if (memcmp(receive_buffer, to_send_buffer, 8) != 0) {
        fprintf(stderr, "Datagram protocol failed\r\n");
        printf("Printing expected output:\r\n");
        printArray(to_send_buffer,8);
        printf("Printing received output:\r\n");
        printArray(receive_buffer,8);
        abort();
    }
    else{
        printf("Data transmission correct! \r\n");
    }
    return 0;
}
